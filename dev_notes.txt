Gendy PD Object

Parameters:
Fundemental Frequency
Number of Breakpoints
Random Walk Step-Size (sigma of the normal) (stability)
Interpolation (Linear, Spline, Sinc)
  Could be variable tension coefficient on the spline(t=0 is linear)
sine-wave conformity

input messages:
float - change frequency (default 300)
h_step X - change horizontal(time) stepsize(mu of the gaussian) to X (in us)
    (default 50)
v_step X - change vertical(amplitude) stepsize to X (default 0.1)
breakpoints X - change number of breakpoints to X (default 8)
interpolation XXXX - change interpolation to linear, spline (default linear)
v_pull X - change how strongly the waveform is pulled to a sine.
    (range 0-1, default 0.5)
h_pull X

Operation:

Each cycle of the waveform is described by a number (N) of breakpoints. After each cycle, the breakpoints move in amplitude and duration according to a random walk. The output signal is generated by interpolating the breakpoints.

initialization arguments:
  frequency, number of breakpoints

pseudocode:

gendy object class
  waveform

  m_signal()



gendy_waveform class
  pointer to first breakpoint
  leftover_waveform[]
  int leftover_length
  int waveform_length
  int num_breakpoints
  int interpolation_type
  float step_width
  float step_height

  set_num_breakpoints(int new_size)

breakpoint class
  pointer to next breakpoint (circular linked list)
  time
  amp
  center_time
  center_amp

  distance_from_list_end()

DSP Loop:
offset = 0
copy leftover waveform to output vector
offset += leftover_length
dest = output_vector
while(dest == output_vector) 
  current_breakpoint = this.breakpoint_list
  if(constrain_endpoints == true)
    set first and last breakpoints to 0 amplitude, time = 0 and waveform_length
  current_breakpoint = current_breakpoint.next
  for each breakpoint 
    calculate new position
      amp_new= amp_old + (1-conformity) * stepsize * gaussian() + 
        conformity * (amp_center - amp_old)
      time_new = time_old + (1-conformity) * stepsize * gaussian() + 
        conformity * (time_center - time_old)
      if time_new < 0; time_new = 0
      if time_new <= previous_breakpoint.time;
        time_new = previous_breakpoint.time+1
      if time_new > waveform_length;
        time_new = waveform_length - breakpoint.distance_from_list_end();
      do
        if amplitude_new > 1
          amplitude_new = 2 - amplitude_new
        if amplitude_new < -1
          amplitude_new = -2 - amplitude_new
      while(amplitude_new < -1 || amplitude_new > 1)
  generate waveform
    if(interpolation == linear)
      current_breakpoint = first breakpoint
      slope = (current_breakpoint.next->amplitude-current_breakpoint.amplitude)/(current_breakpoint.next->time-current_breakpoint.time)
      next_breakpoint_time = current_breakpoint.next->time
      for(i = 0; i < waveform_length; i++)
        if(i >= next_breakpoint_time)
          current_breakpoint = current_breakpoint.next
          slope = (current_breakpoint.next->amplitude-current_breakpoint.amplitude)/(current_breakpoint.next->time-current_breakpoint.time)
          next_breakpoint_time = current_breakpoint.next->time
        if(i+offset >= n)
          leftover_length = waveform_length - i;
          offset = 0
          dest = leftover_waveform
        dest[i+offset] = current_breakpoint.amplitude+slope * (i - current_breakpoint.time)
      
Open Questions:

Are spline and sinc interpolation significantly/audibly different?
Do breakpoints have hard boundaries (mirror boundary), elastic boundaries, or none?
constrain the endpoints to be 0 amplitude for continuity?
